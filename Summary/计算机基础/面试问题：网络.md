# 面试问题：网络

## tcp/udp/ip

### tcp 三次握手过程？

第一次握手是客户端发给服务端一个 SYN 标志位为 1 的包，指明客户端想要与服务端的端口连接，然后再将初始序号 x，保存在包头的序列号中一并发出。发送完毕后，客户端进入 SYN_SEND 状态。
第二次握手是服务器收到客户端的第一次握手信息后，服务端发回 ACK 应答，ACK SYN 标志均置为 1，再将自己的 ISN 序号放到 seq 域里。同时将确认序号 ACKnum 设置为客户端的 ISN+1。发送完毕后，服务端进入 SYN_RCVD 状态。
第三次握手是客户端收到服务端发来的第二次握手信息后，再次发送 ACK 确认 ACK 置为 1，ACKnum 为服务端 ISN+1。发送完毕客户端随即进入 ESTABLISHED 状态，服务端收到后也进入 ESTABLISHED 状态。握手结束

### tcp 连接过程中两次握手行不行？

不行，因为只有至少三次握手通信双方才能得到自己发送出去的序列号，以此验证这条消息是否是历史错误连接导致的错误消息。

### tcp 连接过程中序列号有什么用？

在数据包发送途中可能会遇到这些问题：① 发送方多次发送数据包导致重复 ② 传输途中被路由或其他节点丢失 ③ 多个数据包到达接收方可能没有按照发送顺序排列
tcp 发送途中序列号如何解决这些问题：① 接收方对重复序列号的消息去重 ② 发送方对未被 ACK 的数据包重复发送 ③ 接收方可以通过序列号对消息重新排列

### tcp 为什么能够提供可靠传输？

校验和，确认，重传机制，滑动窗口，拥塞控制

### tcp 四次挥手？

第一次挥手是客户端想要关闭连接，客户端发送一个 FIN 标志位为 1 的包，表示自己准备关闭连接。进入 FIN_WAIT_1 状态。
第二次挥手是服务端收到第一次挥手消息之后，发送 ACK 确认，表示自己收到了客户端发来的消息，但自己可能还在发送消息，所以还没有做好关闭连接的准备，并将 ACKnum 标志位客户端序列号+1，客户端收到后进入 FIN_WAIT_2。
第三次挥手是服务端准备好断开连接了，发送 FIN 为 1，seq 为序列号的包，并进入 LAST_ACK 状态。
第四次挥手是客户端收到第三次挥手消息后，同理发送确认包，并进入 TIME_WAIT 状态，等待 2MSL （两个最大段生命周期）之后，没有收到服务端的 ACK 即认为服务端已经关闭正常连接，于是自己进入 CLOSED 状态。服务端收到第四次挥手信息后也进入 CLOSED 状态。

### 为什么客户端会进入 TIME_WAIT 状态？

因为 ① 防止延迟的数据段被同源地址，源端口，目的地址，目的端口的 TCP 连接收到（第三次挥手下一次连接收到） ② 保证 TCP 连接的远程被正确关闭，即等待服务端收到 FIN 对应的 ACK 消息，服务端如果未正常关闭，它还处于 LAST_ACK 状态，就会向可能的下一个使用相同端口号连接的客户端回复 RST 消息终止新连接的建立

### MSL 是什么？为什么而设计？

为了保证新 TCP 连接的数据段不会与还在网络中传输的历史连接的数据段重复，TCP 连接在分配新的序列号之前需要至少静默数据段在网络上能够存活的最长时间，即 MSL

### 什么是 SYN 攻击？

SYN 攻击是一种典型的 DDoS 攻击，攻击客户端在短时间伪造大量不存在的 IP 地址，向服务端不断发送 SYN 包，服务端需要回复 ACK 给这些不存在的地址，就会不断超时重发，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，可能会导致网络堵塞或者系统瘫痪

### udp 为什么不可靠？

udp 本身缺乏可靠性，没有 tcp 那样保证可靠性的机制，udp 不保证数据包会到达其最终目的地，也不保证各个数据包的先后顺序，也不保证每个数据包只到达一次

### udp 如何实现可靠传输？

### dns 使用什么协议传输？

大多数情况下用 udp，有两种情况使用 tcp 传输

- 数据包大于 512 字节（udp 最大支持 512 字节）
- 区域传输（主域名服务器 - 辅助域名服务器）

### udp 协议头？

udp 协议头只包含 4 个字段，分别是源端口、目的端口、长度和校验码，每个字段占 16 个比特。udp 协议利用下层的 ip 协议提供基本的数据传输能力，其作用就是引入端口号的概念让同一主机提供不同的服务

### ip 分片机制？

不同设备传输数据前，需要先确定一个 ip 数据包的大小上限，即 MTU 最大传输单元，网络路径上的 MTU 由数据链路层上 MTU 最小的物理设备决定，用 udp 传输数据包超过 MTU，ip 协议会进行数据分片传输，ip 协议数据分片对传输层协议是透明的

### tcp 分段和 ip 分片的区别？

①tcp 引入 MSS 最大分段大小，ip 为 MTU 最大传输单元，②MTU 是物理设备上的限制，MSS 是系统内核层面的限制，③ip 协议以数据包为单位组织数据，tcp 协议以数据段为单位组织数据 ④tcp 为了保证可靠性，会通过 MTU 计算出 MSS，以避免 ip 协议对数据包进行分片，因为数据分片对传输层是透明的，如果不做限制，分片会导致失去传输层协议头

### tcp 粘包？

由于 tcp 是字节流传输，不同于 udp 在协议头有数据包长度，所以会发生粘包问题。解决办法就是设置消息边界

### tcp 拥塞控制

慢开始、拥塞控制、快重传、快恢复
慢开始：拥塞窗口 cwnd=1，发送方只能发 1 个报文段，之后 2、4、8... 达到慢开始门限 ssthresh 后，每轮次 cwnd 只+1，超时则 ssthresh = cwnd / 2

### http/https

### get/post 区别？

get 数据量有 url 长度的限制，http 协议规范没有对 url 长度限制，这个限制是特定浏览器和服务器，post 没有大小限制，出于安全考虑，服务器软件在实现时会做限制。get 参数放在 url 里，post 参数放在 body 里，但这只是 http 协议规定，也可以不按规定来

### 条件 get？

请求的时候 header 里带有 `If-Modified-Since` 参数，服务器判断有没有更新，若没有就返回 `304 Not Modified`

### 持久连接？

header 里增加字段 `Connection: Keep-Alive` 在 http 1.1 是默认打开的

### 会话跟踪？

cookie 和 session

### 跨站攻击

CSRF 跨站请求伪造 伪造一个 url 用户点了就会发送请求
XSS 跨站脚本 在可以输入的地方输入一个 js 脚本
预防 CSRF

- 关键操作只能 post
- 验证码
- 检测 referer
- token
  预防 XSS：输入检测并 html escape

### http 1？http 2？

### http code

- **100 Continue** 表明到此为止都很正常，客户端可以继续发送请求或忽略这个响应
- **204 No Content** 请求已经成功，服务器返回的请求不包含实体的主体部分。一般在只需要客户端发送数据时使用
- **206 Partial Content** 表示客户端使用了范围请求，响应报文包含由 Content-Range 指定范围的实体内容
- **301 Moved Permanently** 永久重定向
- **302 Found** 临时性重定向
- **303 See Other** 与 302 有相同功能，但 303 明确要求客户端使用 get 请求
- **304 Not Modified** 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** 临时重定向，与 302 相似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法
- **400 Bad Request** 请求报文中含有语法错误
- **401 Unauthorized** 该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败
- **403 Forbidden** 请求被拒绝
- **404 Not Found**
- **500 Internal Server Error** 服务器正在执行请求时发生错误
- **503 Service Unavailable** 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

### Web 请求过程

1. 假设主机没有 ip 地址，此时生成一个 DHCP 报文 Discover，目的地址 255.255.255.255:67 源地址 0.0.0.0:68 放入 udp 报文段中，放入 ip 数据报中，再放入 MAC 帧中，广播给子网下所有主机，DHCP 服务器收到后发回 Offer 报文，客户端选择 DHCP 报文发送 Request 报文，DHCP 发回 ACK 表示客户端可以使用此信息
2. 现在主机需要为浏览器生成一个 tcp 套接字，为了生成这个套接字，先向 dns 服务器查询对应域名的 ip 地址，主机不知道网关路由器的 MAC 地址，所以先广播一个 ARP 查询报文放入以太帧，路由器收到后发送一个 ARP 回答报文，主机得到路由器的 MAC 地址
3. 主机发送 DNS 查询报文给路由器，路由器抽取出 ip 数据报，由于路由器有内部网关协议（RIP OSPF）和外部网关协议（BGP）这两种路由选择协议，所以路由器已经配置了到达 DNS 服务器的路由表项，DNS 收到后将查询结果发回给路由器，路由器再发回主机
4. （tcp 握手）
5. （tls 握手）
6. http 渲染

### tls 握手全过程

[来源](https://xz.aliyun.com/t/2531)

1. 客户端发送 Client Hello，其中包含的内容为：
    - **客户端版本**（TLS 1.2）
    - **客户端随机数** 4 字节时间戳 + 28 字节随机数
    - **session id** 服务器用 session id 映射对称密钥，客户端确保 session id 是否过期，如未过期可以使用 session id 就不需要完整握手
    - **密码套件** 客户端还发送自己已经知道的密码套件列表，按优先顺序排列
    - **扩展名** 服务器、填充、支持的签名算法等
2. 服务器在接收到客户端发来的握手信息后，根据 tls 版本和其他条件，如服务器接受并支持所有条件，发送 Server Hello，否则发送握手失败
    - **服务器版本** （TLS 1.2）
    - **服务器随机数** 4 字节时间戳 + 28 字节随机数
    - **密码套件** 服务器在客户端发来的密码套件中选一个
    - **session id** 包含到期时间，但对于访问量大的服务器，服务器会根据客户端是否支持创建 session ticket，并使用使用私钥加密的 session 参数，将 session ticket 作为扩展包发送给客户端并存储在客户端里
    - **服务器的证书信息** 服务器按证书信任链的顺序发送完整的证书列表（除根证书），客户端可以识别根证书
    - **版本和序列号** （v3）哪个版本的 X.509 标准
    - **证书的签名算法与值** 哈希算法和计算出的哈希值，以验证签名
    - **颁布机构、合法性** 颁布机构和有效时间
    - **子公钥信息** 携带公钥和生成公钥算法
    - **指纹** 指纹不发给服务器，是客户端生成的，用于识别和组织证书
3. 服务器端密钥交换（当双方使用 Diffie Hellman 算法时才进行这一步）包含服务器的 DH 参数
4. 客户端需要验证服务器身份，若是 DH 算法，则需发送自己的 DH 参数
5. Pre-Master Secret 1. 若使用 RSA 算法，客户端生成 协议版本（2 字节）+ 随机数（46 字节）发给服务器；2. 若使用 DH 算法，双方根据对方的 DH 参数和自己的 DH 参数可以计算出相同的预主密钥
6. 主密钥 双方根据两个随机值和预主密钥计算主密钥

### 杂

- 当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会
